Module 11: Miscellaneous Optimization Techniques

Lab 11-1: Miscellaneous Optimization Techniques - Solution
Lab Setup
There is no additional setup required for this lab. However, if you need to start this lab again at any time, the tables used in this lab can be refreshed by executing the UNIX script renew.sh located in your $HOME/ptquery15 directory
Objectives
After completing this lab, you should be able to:
* Examine the locks that are set up when cursors are used and how cursors are optimized
* Analyze the impact of cursors on other user activity 
* Look at how distincts are optimized
* Look at the differences in optimization of group by clauses

Description
In this lab you will be creating, testing, and analyzing a cursor, examining how distincts are optimized and how group by clauses can be optimized.

Task Outline 
Task 1:  Cursor Optimization 
Task 2:  Interpreting Distinct Optimization
Task 3:  Interpreting Group By Optimization











Detailed Instructions and Solutions
Description
Task 1: Cursor Optimization
This task will focus on the optimization and use of cursors.

Procedure
1.	Analyze the impact of a stand-alone update that locks an entire table.
a.	Login to the server.  In this window (Window A), as the sa, begin an explicit transaction by issuing the begin tran statement.

begin tran
go

b.	Issue the following update statement:

update titles_titlid set type = 'e-business' where type  = 'business'
go



        The titles_titlid table uses the Allpages locking scheme and has the following indexes:
• 	clustered index on the title column
• 	nonclustered index on the title_id column
             • 	nonclustered index on the pub_id column
(552 rows affected)

c.	Examine the locks Adaptive Server is using for the update statement against the titles_titlid table by issuing sp_lock.

sp_lock
go

The class column will display the cursor name for locks associated with a cursor for the current user and the cursor id for other users.
 fid    spid   loid        locktype                     table_id    page
         row    dbname          class
         context
 ------ ------ ----------- ---------------------------- ----------- -----

      0     23          46 Sh_intent                      960003420           0
              0 master          Non Cursor Lock

      0     23          46 Ex_table                       633050260           0
              0 pubtune_db      Non Cursor Lock

(2 rows affected)
(return status = 0)


         
What type of lock(s) does Adaptive Server use for this update statement?
The sa, spid 23 in this example, has an Ex_table (noncursor) lock on the table.

d.	Login to the server in a new session.  In this window (Window B), as user1, activate showplan and noexec.

       
Keep the transaction in Window A active while you perform this new query in Window B.

set showplan, noexec on
go

e.	Continuing in Window B as user1 with showplan activated, issue the following query:

select price, type, title from titles_titlid where title_id = "T400"
go

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	1 operator(s) under root

       |ROOT:EMIT Operator (VA = 1)
       |
       |   |SCAN Operator (VA = 0)
       |   |  FROM TABLE
       |   |  titles_titlid
       |   |  Index : idx2
       |   |  Forward Scan.
       |   |  Positioning by key.
       |   |  Keys are:
       |   |    title_id ASC
       |   |  Using I/O Size 2 Kbytes for index leaf pages.
       |   |  With LRU Buffer Replacement Strategy for index leaf pages.
       |   |  Using I/O Size 2 Kbytes for data pages.
       |   |  With LRU Buffer Replacement Strategy for data pages.        


        
What type of access (table scan or index) does this query attempt to use?
This query against the titles_titlid table uses the index on the title_id column.
If noexec were not enabled, would the query results appear? Explain.
No. The query results would not appear. The exclusive table lock used by the sa in Window A is preventing other users from reading the table data, even for rows and columns not being affected by the update statement. The transaction in Window A must be completed before user1’s query would show results.	

f.	In Window A, as the sa, rollback the transaction.

rollback tran
go

g.	In Window B, turn showplan, noexec off.


set showplan, noexec off
go

QUERY PLAN FOR STATEMENT 1 (at line 1).

    STEP 1
        The type of query is SET OPTION OFF.

2.	Create an updatable cursor for the titles_titlid table.
a.	In Window A, as the sa, declare an updatable cursor as shown.

declare test_cursor2 cursor for
select title_id, type
from titles_titlid
where type = "business"
for update
go

b.	Open the cursor.

open test_cursor2
go

Msg 311, Level 16, State 1:
Server 'DUB101_2K', Line 2:
The optimizer could not find a unique index which it could use to scan table
'titles_titlid' for cursor 'test_cursor2'.

       
Was the cursor declaration successful?
Yes.
Did this updatable cursor open successfully? Explain.
No. The cursor did not open successfully because an updatable cursor requires a unique index.
In the absence of a unique index, how else can an updatable cursor be successfully opened?
Create the table with the unique auto_identity index database option set.
c.	Deallocate the cursor.

       
Even though you cannot open this cursor, you are using system resources. Additionally, you will not be able to declare another cursor with the same name until you deallocate this one.	

deallocate cursor test_cursor2
go

d.	Create a unique index for the titles_titlid table.

create unique index idx4 on titles_titlid (price, title_id)
go

e.	Declare the updatable cursor again:

declare test_cursor2 cursor for
select title_id, type
from titles_titlid
where type = "business"
for update
go

f.	Open the cursor.

open test_cursor2
go

          Did this updatable cursor open successfully with the presence of the unique index?
Yes.
3.	Examine lock management behavior when using updatable cursors.
a.	Determine whether Adaptive Server is using any locks for the updatable cursor after opening it by issuing sp_lock.

sp_lock
go

The class column will display the cursor name for locks associated with a cursor for the current user and the cursor id for other users.


fid    spid   loid        locktype                     table_id    page        row    dbname          class                          context                      
------ ------ ----------- ---------------------------- ----------- ----------- ------ --------------- ------------------------------ ---------------------------- 
0      23     46          Sh_intent                    960003420   0           0      master          Non Cursor Lock                                             
0      23     46          Sh_intent                    633050260   0           0      pubtune_db      test_cursor2
(2 rows affected)
(return status = 0)                                                             

           
With respect to locks, does opening an updatable cursor differ from opening a read-only cursor?
There is no difference. There is now a Sh_intent lock on the titles_titlid table after opening the cursor, even though the cursor is declared for update. In addition, there is still the Sh_intent lock on the master..spt_values table.
The class output displays the name of the cursor, test_cursor2.
b.	In Window A, fetch a row with the cursor.

fetch test_cursor2
go

 title_id type
 -------- ------------
 T20548   business

c.	Examine the locks that are being used while fetching with the cursor.

sp_lock
go

The class column will display the cursor name for locks associated with a cursor for the current user and the cursor id for other users.


fid    spid   loid        locktype                     table_id    page        row    dbname          class                          context                      
------ ------ ----------- ---------------------------- ----------- ----------- ------ --------------- ------------------------------ ---------------------------- 
0      23     46          Sh_intent                    960003420   0           0      master          Non Cursor Lock                                             
0      23     46          Sh_intent                    633050260   0           0      pubtune_db      test_cursor2                                                
0      23     46          Update_page                  633050260   2437        0      pubtune_db      test_cursor2                                                
0      23     46          Update_page                  633050260   12768       0      pubtune_db      test_cursor2


(4 rows affected)
(return status = 0)

           
Does fetching with an updatable cursor use different types of locks as compared with fetching with a read-only cursor? Explain.
Yes. There are two main differences:
1. When fetching from an updatable cursor, the Lock Manager places an update lock (Update_page) on the data page with the first row that was fetched. For the read-only cursor, a shared (Sh_page) lock was used. See the solution for section 1, step 1e.
2. Additionally, because a unique index was required to open this updatable cursor, an update lock (Update_page) is also placed on the leaf index page used to access the first qualifying row. The reason for this is that potentially the fetched row may be modified on the indexed column in a way that causes the index entry to change.	

d.	Continuing in Window A as the sa, begin an explicit transaction by issuing the begin tran statement.

begin tran
go

e.	Modify the currently fetched row as follows:

update titles_titlid set type = "e-business"
where current of test_cursor2
go

(1 row affected)

f.	Examine the locks that are being used while modifying data through the cursor.

sp_lock
go

The class column will display the cursor name for locks associated with a cursor for the current user and the cursor id for other users.


fid    spid   loid        locktype                     table_id    page        row    dbname          class                          context                      
------ ------ ----------- ---------------------------- ----------- ----------- ------ --------------- ------------------------------ ---------------------------- 
0      23     46          Sh_intent                    960003420   0           0      master          Non Cursor Lock                                             
0      23     46          Ex_intent                    633050260   0           0      pubtune_db      Non Cursor Lock                                             
0      23     46          Sh_intent                    633050260   0           0      pubtune_db      test_cursor2                                                
0      23     46          Ex_page                      633050260   2437        0      pubtune_db      Non Cursor Lock                                             
0      23     46          Update_page                  633050260   2437        0      pubtune_db      test_cursor2                                                
0      23     46          Update_page                  633050260   12768       0      pubtune_db      test_cursor2

(6 rows affected)
(return status = 0)

          
Describe the types of locks Adaptive Server uses as a fetched row is updated. Note the class column output of sp_lock.
The Lock Manager continues using a Sh_intent lock on the table and two Update_page locks on the affected data page and the index page used to access the currently fetched row.
But notice now that there is also an Ex_intent lock on the table and an Ex_page lock on the table and the data page containing the updated row. Examine the class column of the output. These exclusive locks are noncursor locks.	
4.	While the cursor and update transaction are still active, have another try to access a different row in the table.
a.	In Window B, as user1, try to access another row from the table as follows:

select price, type, title from titles_titlid where title_id = "T400"
go

 price                 type         title                                                                            
--------------------- ------------ -------------------------------------------------------------------------------- 
35.9500               travel       Echo function for ISO 8473

         
Previously, at the beginning of this section, the sa in Window A updated all books of type “business” to
	“e-business” in a single transaction. An exclusive table lock during that transaction kept another user from querying unaffected rows until the transaction completed, even though the other user was using an index to access the unaffected rows.
The cursor method, performs the updates with individual page locks instead of a table lock. The method can be improved further by committing each row that is modified in a separate transaction.
Did the use of a cursor to perform the updates promote better concurrency? In other words, was the query successful for user1 while the transaction for the sa was still active? Explain.
Yes. Even though the sa in Window A has an active cursor and an active update transaction, user1 is still able to access an unaffected row. There is no concurrency problem in this scenario.
What are alternative ways to promote greater concurrency for scenarios like this where one user may be updating part of a table while other users need to access the data?
One way to promote greater concurrency is to use the Datarows locking scheme for the table instead of Allpages. Another way is to use isolation level 0 (dirty) reads if it is appropriate to do so.	

5.	Clean up.
a. In Window A, roll back the transaction.

rollback tran
go

b. In Window A, close and deallocate the cursor.

close test_cursor2
go

deallocate cursor test_cursor2
go

c. Exit both client sessions with Adaptive Server.
d. In Window B, restore the data in the tables affected by the profiling script to their original state by executing the Unix shell script renew.sh.

           
The script resides in your $HOME/ptquery15 directory.
You perform this step to ensure that the next lab runs the same queries against the same tables and the same data.
renew.sh

Starting copy...
1000 rows sent to SQL Server.
2000 rows sent to SQL Server.
3000 rows sent to SQL Server.
4000 rows sent to SQL Server.
5000 rows sent to SQL Server.
.
.(output deleted)
.

5000 rows copied.
Clock Time (ms.): total = 7000  Avg = 1 (714.29 rows per sec.)

Task 2: Interpreting Distinct Optimization 

Procedure


       

   
  
For all labs, you should open two windows (“A” and “B”). Unless instructed otherwise, perform all lab exercises in Window A. 
Make sure that you have exited ALL open sessions with Adaptive Server and that the operating system prompt appears in both windows. This ensures that your results will be consistent with the solutions for this lab.
1.	Examine how the method for optimizing a distinct when the data is not sorted in that order in the table.
a.	In Window A, connect to Adaptive Server as the sa and access the pubtune_db database.

isql -Usa -P -D pubtune_db

b.	Create a new table to use for the exercise:

select * into titles_d from titles
go

c.	Verify there are no indexes on the table using sp_helpindex.

sp_helpindex titles_d
go

        Object does not have any indexes.
        
  There are no indexes, so there is no underlying data ordering the optimizer can make use of

d.	Turn on showplan and noexec to examine the query plans that will be generated.

set showplan, noexec on
go
e.	Execute the following query

select distinct type from titles_d
go

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	2 operator(s) under root

       |ROOT:EMIT Operator (VA = 2)
       |
       |   |HASH DISTINCT Operator (VA = 1)
       |   | Using Worktable1 for internal storage.
       |   |  Key Count: 1
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  titles_d
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.                                                             


What lava operator is used to perform the distinct? Why?
The Hash Distinct operator is used because there is no underlying data ordering on the table and no ordering is required in the output.


f.	Execute the following query

select distinct type from titles_d
order by type
go

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	2 operator(s) under root

       |ROOT:EMIT Operator (VA = 2)
       |
       |   |SORT Operator (VA = 1)
       |   | Average Row width is 14.000000 
       |   | Using Worktable1 for internal storage.
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  titles_d
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.                                                             
g.	Turn off showplan and noexec.

set showplan, noexec off
go
h.	Turn on set statistics time, showplan and nodata so that execution statistics can be captured and compared later in this lab.

set statistics time on
set showplan, nodata on
go

i.	Rerun the second query

select distinct type from titles_d
order by type
go

type         
------------ 

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	2 operator(s) under root

       |ROOT:EMIT Operator (VA = 2)
       |
       |   |SORT Operator (VA = 1)
       |   | Average Row width is 14.000000 
       |   | Using Worktable1 for internal storage.
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  titles_d
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.


Parse and Compile Time 0.
Adaptive Server cpu time: 0 ms.
 
Execution Time 0.
Adaptive Server cpu time: 0 ms.  Adaptive Server elapsed time: 33 ms.

Using the sort operator, how long does it take to execute the query?
The query takes 33 milliseconds to execute.


j.	Turn off set statistics time, showplan and nodata.

set statistics time off
set showplan, nodata off
go

2.	Examine how creating an clustered index changes the operators chosen by the optimizer
a.	Create a clustered index on the type column of the titles_d table.

create clustered index idx_c on titles_d(type)
go

b.	Turn on showplan and noexec to examine the query plans that will be generated.

set showplan, noexec on
go

c.	Execute the following query

select distinct type from titles_d 
go

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	2 operator(s) under root

       |ROOT:EMIT Operator (VA = 2)
       |
       |   |GROUP SORTED Operator (VA = 1)
       |   |Distinct
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  titles_d
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.                                                             

What lava operator is used to perform the distinct? Why?
The Group Sorted (Distinct) operator is used because the data is sorted in order.  Regardless of whether or not the data needs to be returned in order, the Group Sorted operator will be used to avoid the overhead of a sort.
	
d.	Turn off showplan and noexec.

set showplan, noexec off
go
e.	Turn on set statistics time, showplan and nodata so that execution statistics can be captured and compared to the orde by query we ran earlier in this lab.

set statistics time on
set showplan, nodata on
go

f.	Rerun the distinct query with the order by

select distinct type from titles_d
order by type
go

        type         
        ------------ 
        
        QUERY PLAN FOR STATEMENT 1 (at line 1).
        
        
            STEP 1
                The type of query is SELECT.
        
        	2 operator(s) under root
        
               |ROOT:EMIT Operator (VA = 2)
               |
               |   |GROUP SORTED Operator (VA = 1)
               |   |Distinct
               |   |
               |   |   |SCAN Operator (VA = 0)
               |   |   |  FROM TABLE
               |   |   |  titles_d
               |   |   |  Table Scan.
               |   |   |  Forward Scan.
               |   |   |  Positioning at start of table.
               |   |   |  Using I/O Size 2 Kbytes for data pages.
               |   |   |  With LRU Buffer Replacement Strategy for data pages.
        
        
        Parse and Compile Time 0.
        Adaptive Server cpu time: 0 ms.
         
        Execution Time 0.
Adaptive Server cpu time: 0 ms.  Adaptive Server elapsed time: 0 ms.
        
        
What lava operator was used?  Why?
The Group Sorted operator is used because the data is sorted in the order of the distinct column.  
Which method executed the query faster?
The sort operator executed the query in 33 milliseconds, whereas the group sorted operator allowed the query to be executed in less than 1 millisecond.  The 2nd version of the query runs faster because a sorting of the data is not required.

g.	Turn off set statistics time, showplan and nodata.

set statistics time off
set showplan, nodata off
go

h.	Drop the table used in this task.

drop table titles_d
go







Task 3: Interpreting Group By Optimization 
Description
In this task you’ll evaluate the optimization techniques used to optimize a query utilizing a vector aggregate (an aggregate query with a group by)

Procedure


       

   
  
For all labs, you should open two windows (“A” and “B”). Unless instructed otherwise, perform all lab exercises in Window A. 
Make sure that you have exited ALL open sessions with Adaptive Server and that the operating system prompt appears in both windows. This ensures that your results will be consistent with the solutions for this lab.
1.	Examine how the methods for optimizing a distinct when the data is not sorted in that order in the table.
a.	In Window A, connect to Adaptive Server as the sa and access the pubtune_db database.

isql -Usa -P -D pubtune_db

b.	Create a new table to use for the exercise:

select * into titles_g from titles
go

c.	Verify there are no indexes on the table using sp_helpindex.

sp_helpindex titles_g
go

        Object does not have any indexes.
        
  There are no indexes, so there is no underlying data ordering the optimizer can make use of

d. Turn on set statistics time, showplan and nodata so that execution statistics can be captured and compared later in this lab.

set statistics time on
set showplan, nodata on
go
e.	Execute the following query

select count(type) from titles_g
group by type
go

            
----------- 

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	2 operator(s) under root

       |ROOT:EMIT Operator (VA = 2)
       |
       |   |HASH VECTOR AGGREGATE Operator (VA = 1)
       |   |  GROUP BY
       |   |  Evaluate Grouped COUNT AGGREGATE.
       |   | Using Worktable1 for internal storage.
       |   |  Key Count: 1
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  titles_g
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.


Parse and Compile Time 0.
Adaptive Server cpu time: 0 ms.
 
Execution Time 0.
Adaptive Server cpu time: 0 ms.  Adaptive Server elapsed time: 3 ms.


What lava operator was used?  Why?
The Hash Vector Aggregate operator is used because the data is not sorted in type column order.  
How long did the query take to execute?
The sort operator executed the query in 3 milliseconds.

f.	Turn off set statistics time, showplan and nodata.

set statistics time off
set showplan, nodata off
go

g. Enable the group inserting operator so the optimizer uses it instead of the hash vector aggregate operator.

        set group_sorted off
        set group_hashing off
        set group_inserting on
        go
        
h. Turn on set statistics time, showplan and nodata.

set statistics time on
set showplan, nodata on
        go
        
i. Execute the following query

select count(type) from titles_g
group by type
go

            
            
----------- 

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	2 operator(s) under root

       |ROOT:EMIT Operator (VA = 2)
       |
       |   |GROUP INSERTING Operator (VA = 1)
       |   |  GROUP BY
       |   |  Evaluate Grouped COUNT AGGREGATE.
       |   | Using Worktable1 for internal storage.
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  titles_g
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.


Parse and Compile Time 0.
Adaptive Server cpu time: 0 ms.
 
Execution Time 0.
Adaptive Server cpu time: 0 ms.  Adaptive Server elapsed time: 13 ms.

 
What lava operator was used?  Why?
The Group Inserting operator is used because the data is not sorted in type column order and the hash vector operator is disallowed via the optimzation criteria settings  
How long did the query take to execute?
The group inserting operator executed the query in 13 milliseconds.
Which method is faster?
The hash vector aggregate operator executed the query in 3 milliseconds, so it is faster.

NOTE:  The group inserting operator is disabled for all optimization goals.  In order for it to be used , the group_hashing optimization criteria must be disabled manually.  It is on for ALL optimization goals.  The hashing operator can, in some cases, place too large a load on tempdb.  The use of the group inserting operator forces the optimizer to use the 12.5 methodology. 
                                                            
j. Turn off set statistics time, showplan and nodata.

set statistics time off
set showplan, nodata off
go
k. Disable the group inserting operator so the optimizer will no longer consider it.

        set group_sorted on
        set group_hashing on
        set group_inserting off
        go

2.	Examine how creating an clustered index changes the operators chosen by the optimizer
a.	Turn on set statistics time, showplan and nodata.

set statistics time on
set showplan, nodata on
        go
        
b.	Execute the following query

        select count(type) from titles_g
        group by type
        order by type
        go
            
            
            
----------- 

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	3 operator(s) under root

       |ROOT:EMIT Operator (VA = 3)
       |
       |   |SORT Operator (VA = 2)
       |   | Average Row width is 18.000000 
       |   | Using Worktable2 for internal storage.
       |   |
       |   |   |HASH VECTOR AGGREGATE Operator (VA = 1)
       |   |   |  GROUP BY
       |   |   |  Evaluate Grouped COUNT AGGREGATE.
       |   |   | Using Worktable1 for internal storage.
       |   |   |  Key Count: 1
       |   |   |
       |   |   |   |SCAN Operator (VA = 0)
       |   |   |   |  FROM TABLE
       |   |   |   |  titles_g
       |   |   |   |  Table Scan.
       |   |   |   |  Forward Scan.
       |   |   |   |  Positioning at start of table.
       |   |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |   |  With LRU Buffer Replacement Strategy for data pages.


Parse and Compile Time 0.
Adaptive Server cpu time: 0 ms.
 
Execution Time 0.
Adaptive Server cpu time: 0 ms.  Adaptive Server elapsed time: 16 ms.

 
What lava operator was used?  Why?
The Hash Vector Aggregate operator is used because the data is not sorted in type column order.  
How long did the query take to execute?
The sort operator executed the query in 16 milliseconds.
c.	Turn off set statistics time, showplan and nodata.

set statistics time off
set showplan, nodata off
		go
d.	Create a clustered index on the type column of the titles_g table.

create clustered index idx_c on titles_g(type)
go

e.	Turn on set statistics time, showplan and nodata so that execution statistics can be captured and compared to the orde by query we ran earlier in this lab.

set statistics time on
set showplan, nodata on
go

f.	Rerun the distinct query with the order by

select count(type) from titles_g
group by type
order by type 
go

            
----------- 

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	2 operator(s) under root

       |ROOT:EMIT Operator (VA = 2)
       |
       |   |GROUP SORTED Operator (VA = 1)
       |   |  Evaluate Grouped COUNT AGGREGATE.
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  titles_g
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.


Parse and Compile Time 0.
Adaptive Server cpu time: 0 ms.
 
Execution Time 0.
Adaptive Server cpu time: 0 ms.  Adaptive Server elapsed time: 0 ms.
        
        
What lava operator was used?  Why?
The Group Sorted operator is used because the data is sorted in the order of the group by column.  
Which method executed the query faster?
The sort operator executed the query in 16 milliseconds, whereas the group sorted operator allowed the query to be executed in less than 1 millisecond.  The 2nd version of the query runs faster because a sorting of the data is not required.
g.	Turn off set statistics time, showplan and nodata.

set statistics time off
set showplan, nodata off
		go

h.	Disable the group_sorted operator by using the optimization criteria.

        set group_sorted off
        go
        
i.	Turn on set statistics time, showplan and nodata.

set statistics time on
set showplan, nodata on
        go
        
j.	Execute the following query

select count(type) from titles_g
group by type
order by type 
go

            
            
----------- 

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	3 operator(s) under root

       |ROOT:EMIT Operator (VA = 3)
       |
       |   |SORT Operator (VA = 2)
       |   | Average Row width is 18.000000 
       |   | Using Worktable2 for internal storage.
       |   |
       |   |   |HASH VECTOR AGGREGATE Operator (VA = 1)
       |   |   |  GROUP BY
       |   |   |  Evaluate Grouped COUNT AGGREGATE.
       |   |   | Using Worktable1 for internal storage.
       |   |   |  Key Count: 1
       |   |   |
       |   |   |   |SCAN Operator (VA = 0)
       |   |   |   |  FROM TABLE
       |   |   |   |  titles_g
       |   |   |   |  Table Scan.
       |   |   |   |  Forward Scan.
       |   |   |   |  Positioning at start of table.
       |   |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |   |  With LRU Buffer Replacement Strategy for data pages.


Parse and Compile Time 0.
Adaptive Server cpu time: 0 ms.
 
Execution Time 0.
Adaptive Server cpu time: 0 ms.  Adaptive Server elapsed time: 6 ms.

What lava operator was used?  Why?
The Hash Vector Aggregate operator is used because the data is not sorted in type column order.  
How long did the query take to execute?
The sort operator executed the query in 6 milliseconds.                                                            
k.	Turn off set statistics time, showplan and nodata.

set statistics time off
set showplan, nodata off
go

l.	Enable the group_sorted optimization criteria to return the setting to it’s default status of on.

set group_sorted on
go

m.	Drop the table used in this task.

drop table titles_g
go



