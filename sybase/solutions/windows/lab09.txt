Module 9: Joins

Lab 9-1: Analyzing Join Plans - Solution
Lab Setup
There is a setup and a cleanup script required for this lab.
If you need to start this lab again at any time, the tables used in this lab can be refreshed by executing the UNIX shell script named joins_setup.sh located in your $HOME/ptquery15 directory.

Objectives
After completing this lab, you should be able to:
* Analyze various join types
* Review join order
* Review tuning tools for joins

Description
In this lab you will learn to analyze the types of Joins by setting the optimization goals that best fits the query environment. You will also learn about the Join Order and query tuning tools for joins.

Task Outline 
Task 1: Analyzing Types of Joins: Nested Loop Joins, Merge Joins, Hash Joins and N-ary NLJ
Task 2: Reviewing Join Order
Task 3: Reviewing Tuning Tools for Joins

Detailed Instructions and Solutions
Task 1: Analyzing Types of Joins: Nested Loop Joins, Merge Joins, Hash Joins, and N-ary NLJ
Description
In this task you will learn the different types of Joins.

Procedure

       

   
  
For all labs, you should open two windows (“A” and “B”). Unless instructed otherwise, perform all lab exercises in Window A. 
Make sure that you have exited ALL open sessions with Adaptive Server and that the operating system prompt appears in both windows. This ensures that your results will be consistent with the solutions for this lab.
1. Perform the lab setup.
a. Change the directory to $HOME/ptquery15.

cd $HOME/ptquery15

b. Execute the UNIX shell script joins_setup.sh.

joins_setup.sh

##################################
Setting up tables for Joins ...
##################################
Database option 'select into/bulkcopy/pllsort' turned ON for database 'pubtune_db'.
Running CHECKPOINT on database 'pubtune_db' for option 'select
into/bulkcopy/pllsort' to take effect.
(return status = 0)

(output deleted)

Starting copy...

87 rows copied.
Clock Time (ms.): total = 15  Avg = 0 (5800.00 rows per sec.)

2. Activate Adaptive Server diagnostic commands.
a. In Window A, connect to Adaptive Server as sa using the NULL password and access the pubtune_db database.

isql -Usa -P –Dpubtune_db

b. Observe the indexes that exist for the tables that were created by the setup script and will be used in the queries in the steps below and fill in the table.

exec sp_helpindex sales_idnum
exec sp_helpindex salesdetail_idnum

Object has the following indexes

index_name index_keys        index_description index_max_rows_per_page index_fillfactor index_reservepagegap index_created       index_local  
---------- ----------------- ----------------- ----------------------- ---------------- -------------------- ------------------- ------------ 
storordind  stor_id, ord_num clustered, unique                       0                0                    0 Feb 22 2009  2:24PM Global Index 


index_ptn_name       index_ptn_seg 
-------------------- ------------- 
storordind_265048949 default       


Object has the following indexes
 


index_name   index_keys        index_description index_max_rows_per_page index_fillfactor index_reservepagegap index_created       index_local  
------------ ----------------- ----------------- ----------------------- ---------------- -------------------- ------------------- ------------ 
titleind      title_id         nonclustered                            0                0                    0 Feb 22 2009  2:24PM Global Index 
sdstorordind  stor_id, ord_num nonclustered                            0                0                    0 Feb 22 2009  2:24PM Global Index 


index_ptn_name         index_ptn_seg 
---------------------- ------------- 
titleind_297049063     default       
sdstorordind_297049063 default

(2 rows affected)

TABLEINDEXCOLUMNSTYPEsales_idnum
storordindstor_id, ord_numclusteredsalesdetail_idnum
sdstorordindstor_id, ord_numnonclusteredsalesdetail_idnum
titleindtitle_idnonclustered
c. Activate showplan and noexec to examine optimizer output without actually executing a query.


You can set both showplan and noexec on with one command:
set showplan, noexec on
The sequence does not matter when you use one command. For example:
set noexec, showplan on
produces the same net effect.
set showplan, noexec on

3. Execute the following queries A, B, C, and D, examine the showplan output and identify the join method operators in the questions that follow each query.  (You can find these queries in a file in your $HOME/ptquery15 directory called "lab8_queries.sql" )

a. Query A

select s.date, sd.qty
from sales_idnum s, salesdetail_idnum sd
where s.stor_id = sd.stor_id 
and s.ord_num = sd.ord_num 
plan “(use optgoal allrows_oltp)”

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	3 operator(s) under root

       |ROOT:EMIT Operator (VA = 3)
       |
       |   |NESTED LOOP JOIN Operator (VA = 2) (Join Type: Inner Join)
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  sales_idnum
       |   |   |  s
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.
       |   |
       |   |   |SCAN Operator (VA = 1)
       |   |   |  FROM TABLE
       |   |   |  salesdetail_idnum
       |   |   |  sd
       |   |   |  Index : sdstorordind
       |   |   |  Forward Scan.
       |   |   |  Positioning by key.
       |   |   |  Keys are:
       |   |   |    stor_id ASC
       |   |   |    ord_num ASC
       |   |   |  Using I/O Size 2 Kbytes for index leaf pages.
       |   |   |  With LRU Buffer Replacement Strategy for index leaf pages.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.



Which join method is used ( Nested Loop Join, Merge Join, Hash Join, N-ary NLJ)? Why?
Nested Loop Join method is used because the optimization goal specified is “allrows_oltp” in the query.  

b. Query B

select s.date, sd.qty
from sales_idnum s, salesdetail_idnum sd
where s.stor_id = sd.stor_id 
and s.ord_num = sd.ord_num 

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	4 operator(s) under root

       |ROOT:EMIT Operator (VA = 4)
       |
       |   |MERGE JOIN Operator (Join Type: Inner Join) (VA = 3)
       |   | Using Worktable2 for internal storage.
       |   |  Key Count: 2
       |   |  Key Ordering: ASC ASC
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  sales_idnum
       |   |   |  s
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.
       |   |
       |   |   |SORT Operator (VA = 2)
       |   |   | Average Row width is 22.365385 
       |   |   | Using Worktable1 for internal storage.
       |   |   |
       |   |   |   |SCAN Operator (VA = 1)
       |   |   |   |  FROM TABLE
       |   |   |   |  salesdetail_idnum
       |   |   |   |  sd
       |   |   |   |  Table Scan.
       |   |   |   |  Forward Scan.
       |   |   |   |  Positioning at start of table.
       |   |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |   |  With LRU Buffer Replacement Strategy for data pages.



Which join method is used ( Nested Loop Join, Merge Join, Hash Join, N-ary NLJ)? 
Merge Join method 
Explain:
There are indexes on the join columns that can be taken advantage of and the default optimization goal that is applied is  "allrows_mix".  The merge join is determined to be more efficient than the nested loop join, while hash join is not allowed.


c. Query C

select s.date, sd.qty
from sales_idnum s, salesdetail_idnum sd
where s.stor_id = sd.stor_id 
and s.ord_num = sd.ord_num 
plan “(use optgoal allrows_dss)”

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	3 operator(s) under root

       |ROOT:EMIT Operator (VA = 3)
       |
       |   |HASH JOIN Operator (VA = 2) (Join Type: Inner Join)
       |   | Using Worktable1 for internal storage.
       |   |  Key Count: 2
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  sales_idnum
       |   |   |  s
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.
       |   |
       |   |   |SCAN Operator (VA = 1)
       |   |   |  FROM TABLE
       |   |   |  salesdetail_idnum
       |   |   |  sd
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.


Which join method is used ( Nested Loop Join, Merge Join, Hash Join, N-ary NLJ)? 
Hash Join method 
Explain:
The optimization goal that is applied is  "allrows_dss" and the hash join was chosen as most efficient method of processing the join, when compared to nested loop and merge join methods.
d. Query D

select t.title, p.pub_name, r.royalty
from publishers_id p, titles_tid t, roysched_id r
where p.pub_id = t.pub_id
and t.title_id = r.title_id
and t.pub_id = r.title_id
and p.state = “CA”
plan “(use optgoal allrows_oltp)”

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	5 operator(s) under root

       |ROOT:EMIT Operator (VA = 5)
       |
       |   |N-ARY NESTED LOOP JOIN Operator (VA = 4) has 3 children.
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  publishers_id
       |   |   |  p
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.
       |   |
       |   |   |RESTRICT Operator (VA = 2)(0)(0)(0)(4)(0)
       |   |   |
       |   |   |   |SCAN Operator (VA = 1)
       |   |   |   |  FROM TABLE
       |   |   |   |  titles_tid
       |   |   |   |  t
       |   |   |   |  Using Clustered Index.
       |   |   |   |  Index : titleidind
       |   |   |   |  Forward Scan.
       |   |   |   |  Positioning by key.
       |   |   |   |  Keys are:
       |   |   |   |    title_id ASC
       |   |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |   |  With LRU Buffer Replacement Strategy for data pages.
       |   |
       |   |   |SCAN Operator (VA = 3)
       |   |   |  FROM TABLE
       |   |   |  roysched_id
       |   |   |  r
       |   |   |  Index : titleidind
       |   |   |  Forward Scan.
       |   |   |  Positioning by key.
       |   |   |  Keys are:
       |   |   |    title_id ASC
       |   |   |  Using I/O Size 2 Kbytes for index leaf pages.
       |   |   |  With LRU Buffer Replacement Strategy for index leaf pages.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.


Which Join Method is used ( Nested Loop Join, Merge Join, Hash Join, N-ary NLJ)? 
N-ary Nested Loop Join 
 Explain:
There are more than 2 tables in the join and the allrows_oltp optimization goal only allows Nested Loop Joins
4. Modify Query A, add an additional where condition and examine the showplan results

a. Modified Query A

select s.date, sd.qty
from sales_idnum s, salesdetail_idnum sd
where s.stor_id = sd.stor_id 
and s.ord_num = sd.ord_num 
and s.date = “03/01/1991”   <-- here is the new condition
plan “(use optgoal allrows_oltp)”

UERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	3 operator(s) under root

       |ROOT:EMIT Operator (VA = 3)
       |
       |   |NESTED LOOP JOIN Operator (VA = 2) (Join Type: Inner Join)
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  sales_idnum
       |   |   |  s
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.
       |   |
       |   |   |SCAN Operator (VA = 1)
       |   |   |  FROM TABLE
       |   |   |  salesdetail_idnum
       |   |   |  sd
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.



How did the query plan change? Why?
The addition of the additional search condition change the access methods from index scans to table scans.  This is because the optimizer now factors in the date column when determining the number of rows that will meet the join and search conditions.


b. Still in Window A, deativate the Adaptive Server diagnostic commands.

set showplan, noexec off

c. Activate new Adaptive Server diagnostic commands

set statistics time on

set showplan, nodata on




d. Re-execute Modified Query A

select s.date, sd.qty
from sales_idnum s, salesdetail_idnum sd
where s.stor_id = sd.stor_id 
and s.ord_num = sd.ord_num 
and s.date = “03/01/1991”
plan “(use optgoal allrows_oltp)”

date                      qty    
------------------------- ------ 

QUERY PLAN FOR STATEMENT 1 (at line 1).


    STEP 1
        The type of query is SELECT.

	3 operator(s) under root

       |ROOT:EMIT Operator (VA = 3)
       |
       |   |NESTED LOOP JOIN Operator (VA = 2) (Join Type: Inner Join)
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  sales_idnum
       |   |   |  s
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.
       |   |
       |   |   |SCAN Operator (VA = 1)
       |   |   |  FROM TABLE
       |   |   |  salesdetail_idnum
       |   |   |  sd
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.


Parse and Compile Time 0.
Adaptive Server cpu time: 0 ms.
 
Execution Time 0.
Adaptive Server cpu time: 0 ms.  Adaptive Server elapsed time: 0 ms.
Execution time: 0.031 seconds

e. Re-execute Modified Query Aagain, forcing the use of the sdstorordind index on salesdetail_idnum as shown below

select s.date, sd.qty
from sales_idnum s, salesdetail_idnum sd (index sdstorordind)
where s.stor_id = sd.stor_id 
and s.ord_num = sd.ord_num 
and s.date = “03/01/1991”
plan “(use optgoal allrows_oltp)”

QUERY PLAN FOR STATEMENT 1 (at line 1).
Optimized using the forced options (internally generated Abstract Plan).


    STEP 1
        The type of query is SELECT.

	3 operator(s) under root

       |ROOT:EMIT Operator (VA = 3)
       |
       |   |NESTED LOOP JOIN Operator (VA = 2) (Join Type: Inner Join)
       |   |
       |   |   |SCAN Operator (VA = 0)
       |   |   |  FROM TABLE
       |   |   |  sales_idnum
       |   |   |  s
       |   |   |  Table Scan.
       |   |   |  Forward Scan.
       |   |   |  Positioning at start of table.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.
       |   |
       |   |   |SCAN Operator (VA = 1)
       |   |   |  FROM TABLE
       |   |   |  salesdetail_idnum
       |   |   |  sd
       |   |   |  Index : sdstorordind
       |   |   |  Forward Scan.
       |   |   |  Positioning by key.
       |   |   |  Keys are:
       |   |   |    stor_id ASC
       |   |   |    ord_num ASC
       |   |   |  Using I/O Size 2 Kbytes for index leaf pages.
       |   |   |  With LRU Buffer Replacement Strategy for index leaf pages.
       |   |   |  Using I/O Size 2 Kbytes for data pages.
       |   |   |  With LRU Buffer Replacement Strategy for data pages.


Parse and Compile Time 0.
Adaptive Server cpu time: 0 ms.
 
Execution Time 0.
Adaptive Server cpu time: 0 ms.  Adaptive Server elapsed time: 0 ms.
Execution time: 0.032 seconds



Was the optimizer making the right decision in reverting to a table scan?
Yes.  Though the difference is minor, it is faster to use the index.  Note that this is a very small sample size of data, so the difference in execution time would be magnified with larger data sets.


5. Still in Window A, deactivate Adaptive Server diagnostic commands.

set showplan, nodata off

set statistics time off

QUERY PLAN FOR STATEMENT 1 (at line 1).

    STEP 1
        The type of query is SET OPTION OFF.



Task 2: Reviewing Join Order
Description
In this task, you will learn about the methods used for analyzing the Join Order.

Procedure
1. In Window A, as the sa connected to Adaptive Server, analyze the Join Order and data access method for a query.
a. Activate trace flag 3604 by using dbcc traceon and set option show_search_engine


   
set option show_search_engine is used to examine the join order algorithm used by the optimizer.

dbcc traceon(3604)
   set option show_search_engine on

DBCC execution completed. If DBCC printed error messages, contact a user with System Administrator (SA) role.


b. Activate the Adaptive Server command noexec to examine optimizer output without actually executing the query.

set noexec on


c. Execute the following query and examine the join order algorithm used by the optimizer.

Query E

select t.title
from titles_idpr t, titleauthor_ididtid ta
where t.title_id = ta.title_id 
and ta.royaltyper = 61 and t.type = “business”
plan “(use optgoal allrows_oltp)”



OptCriteria:
append_union_all
alternative_greedy_search
distinct_hashing
distinct_sorted
distinct_sorting
group_hashing
group_sorted
hash_union_distinct
index_union
merge_union_all
merge_union_distinct
nary_nl_join
nl_join
order_sorting
replicated_partition
streaming_sort
store_index

Optimization Goal: allrows_oltp 
Session Level Optimization Goal has been set.
Optimization Learning mode disabled.

Optimization Timeout limit: 10% (Default)
Server Level Optimization Timeout has been set.
Optimization query tuning time limit enabled.
The compiler will use the current best plan when 10%(Optimization Timeout limit) of average execution time is exceeded.

Optimization query tuning mem limit enabled.
The compiler will use the current best plan when 10%(Max Resource Granularity) of procedure cache is exceeded.


******************************************************************
          BEGIN: Search Space Traversal for OptBlock0 
******************************************************************

Scan plans selected for this optblock:


OptBlock0 Eqc{0} -> Pops added: 

	( PopIndScan idx1 titles_idpr t ) cost: 17371 T(L623,P621,C6000) O(L623,P621,C6000) order: {2} 
	
	
OptBlock0 Eqc{1} -> Pops added: 

	( PopIndScan idx1 titleauthor_ididtid ta ) cost: 3589 T(L107,P105,C7500) O(L107,P105,C7500) order: none 
	
	( PopSort ( PopIndScan idx1 titleauthor_ididtid ta ) ) cost: 4065.859 T(L113,P105,C12148.59) O(L6,P0,C4648.595) order: {2} 
	
	

Permutation Order: Gt0( titles_idpr t ) |X| Gt1( titleauthor_ididtid ta )


Join plans selected for this permutation:

OptBlock0 Eqc{0,1} -> Pops added for the join Eqc{0} - Eqc{1}:
	
	( PopNlJoin ( PopIndScan idx1 titles_idpr t ) ( PopRidJoin ( PopIndScan idx2 titleauthor_ididtid ta ) ) ) cost: 24686.4 T(L2241.192,P782.7205,C6360.023) order: none 
	
	

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    DONE: Complete join order evaluation (perm #1)    
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Permutation Order: Gt1( titleauthor_ididtid ta ) |X| Gt0( titles_idpr t )


Join plans selected for this permutation:

OptBlock0 Eqc{0,1} -> Pops added for the join Eqc{1} - Eqc{0}:
	
	( PopNlJoin ( PopIndScan idx1 titleauthor_ididtid ta ) ( PopIndScan idx1 titles_idpr t ) ) cost: 23101.5 T(L1982,P728,C9375) order: none 
	
	

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    DONE: Complete join order evaluation (perm #2)    
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

==================================================================
       DONE: Left deep tree evaluation (tree #1)
==================================================================

------------------------------------------
Search Engine Statistics (Summary)
------------------------------------------

Total number of tree shapes considered:1
Number of major tree shapes generated:1
Number of tree shapes generated by flipping major tree shapes:0

Number of valid complete plans evaluated:2
Total number of complete plans evaluated:2

------------------------------------------

The best plan found in OptBlock0 : 

( PopNlJoin cost: 23101.5 props: [{}] ( PopIndScan cost: 3589 T(L107,P105,C7500) O(L107,P105,C7500) props: [{}] Gti1( idx1 ) Gtt1( titleauthor_ididtid ta ) ) cost: 3589 T(L107,P105,C7500) O(L107,P105,C7500) order: none 
( PopIndScan cost: 81.3 T(L1875,P623,C1875) O(L1875,P623,C1875) props: [{2}] Gti0( idx1 ) Gtt0( titles_idpr t ) ) cost: 81.3 T(L1875,P623,C1875) O(L1875,P623,C1875) order: {2} 
) cost: 23101.5 order: none 


******************************************************************
          DONE: Search Space Traversal for OptBlock0 
******************************************************************

According to the output, how many Permutation Orders were evaluated, one or two?
Two permutation orders were evaluated.
Which permutation order has the lower cost, perm #1 or perm #2?
Perm #2  has the lower cost (23101.5) as compared to Perm #1 (24686.4)  
Which permutation order is chosen as the best plan, perm #1 or perm #2? Why?
Perm #2  which has the lower cost (23101.5) is chosen as the best plan because the optimizer always chooses the cheaper plan as the best plan.
Does the output indicate that Nested Loop Join is used? How?
Yes
For show_search_engine, notice the line of output that reads:
“PopNlJoin “
which clearly indicates that a Nested Loop Join Strategy has been used.
2. In Window A, turn off the Adaptive Server command noexec.

set noexec off


Task 3: Reviewing Tuning Tools for Joins
Description
In this task, you will examine the useful statistics missing from a query and how they affect the selection of join type and costing of a plan.

Procedure
1. In Window A, as the sa connected to Adaptive Server, examine the useful statistics missing from a query.
a. Activate  set option show_missing_stats


   
set option show_missing_stats is used to examine the useful statistics missing from the SARG/Join column.
   dbcc traceon(3604)
   set option show_missing_stats on

b. Activate the Adaptive Server command noexec to examine optimizer output without actually executing the query.

set noexec on

c. Execute the following query and examine the useful statistics missing from the Join column. Also note the Join type and the cost .

Query F

select t.title, sd.discount
from titles_id t, salesdetail_idnum sd
where t.title_id = sd.title_id 
and sd.discount = 10


NO STATS on column titles_id.title_id
NO STATS on column salesdetail_idnum.title_id
NO STATS on column salesdetail_idnum.discount

OptCriteria:
append_union_all
alternative_greedy_search
distinct_hashing
distinct_sorted
distinct_sorting
group_hashing
group_sorted
hash_union_distinct
index_union
merge_join
merge_union_all
merge_union_distinct
nary_nl_join
nl_join
order_sorting
parallel_query
replicated_partition
streaming_sort
store_index

Optimization Goal: allrows_mix 
Optimization Learning mode disabled.

Optimization Timeout limit: 10% (Default)
Server Level Optimization Timeout has been set.
Optimization query tuning time limit enabled.
The compiler will use the current best plan when 10%(Optimization Timeout limit) of average execution time is exceeded.

Optimization query tuning mem limit enabled.
The compiler will use the current best plan when 10%(Max Resource Granularity) of procedure cache is exceeded.


******************************************************************
          BEGIN: Search Space Traversal for OptBlock0 
******************************************************************

Scan plans selected for this optblock:


OptBlock0 Eqc{0} -> Pops added: 

	( PopIndScan titidind titles_id t ) cost: 86.39999 T(L3,P3,C54) O(L3,P3,C54) order: {1} 
	
	
OptBlock0 Eqc{1} -> Pops added: 

	( PopTabScan salesdetail_idnum sd ) cost: 121.92 T(L4,P4,C139.2) O(L4,P4,C139.2) order: none 
	
	( PopSort ( PopTabScan salesdetail_idnum sd ) ) cost: 137.9232 T(L10,P4,C179.2317) O(L6,P0,C40.03166) order: {1} 
	
	

Permutation Order: Gt0( titles_id t ) |X| Gt1( salesdetail_idnum sd )


Join plans selected for this permutation:

OptBlock0 Eqc{0,1} -> Pops added for the join Eqc{0} - Eqc{1}:
	
	( PopMergeJoin ( PopIndScan titidind titles_id t ) ( PopSort ( PopTabScan salesdetail_idnum sd ) ) ) cost: 226.4111 T(L13,P6.999999,C254.1117) O(L0,P0,C20.88) order: none 
	
	

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    DONE: Complete join order evaluation (perm #1)    
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Permutation Order: Gt1( salesdetail_idnum sd ) |X| Gt0( titles_id t )


Join plans selected for this permutation:

!! This complete join order is expensive !!
!! Rejecting it !!


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    DONE: Complete join order evaluation (perm #2)    
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

=====================================================================
       DONE: Left deep tree evaluation (tree #1)
=====================================================================

------------------------------------------
Search Engine Statistics (Summary)
------------------------------------------

Total number of tree shapes considered:1
Number of major tree shapes generated:1
Number of tree shapes generated by flipping major tree shapes:0

Number of valid complete plans evaluated:1
Total number of complete plans evaluated:2

------------------------------------------

The best plan found in OptBlock0 : 

( PopMergeJoin cost: 226.4111 props: [{}] ( PopIndScan cost: 86.39999 T(L3,P3,C54) O(L3,P3,C54) props: [{1}] Gti0( titidind ) Gtt0( titles_id t ) ) cost: 86.39999 T(L3,P3,C54) O(L3,P3,C54) order: {1} 
( PopSort cost: 137.9232 T(L10,P4,C179.2317) O(L6,P0,C40.03166) props: [{1}] ( PopTabScan cost: 121.92 T(L4,P4,C139.2) O(L4,P4,C139.2) props: [{}] Gtt1( salesdetail_idnum sd ) ) cost: 121.92 T(L4,P4,C139.2) O(L4,P4,C139.2) order: none 
) cost: 137.9232 T(L10,P4,C179.2317) O(L6,P0,C40.03166) order: {1} 
) cost: 226.4111 order: none 

******************************************************************
          DONE: Search Space Traversal for OptBlock0 
******************************************************************


According to the output, which columns have missing statistics?
There are three columns having missing statistics:
* titles_id.title_id
* salesdetail_idnum.discount 
* salesdetail_idnum.title_id.
Which Join method ( Nested Loop Join, Merge Join , Hash Join or N-ary NLJ) is used and what is the cost ?
A Merge Join is used and the cost is 226. 4111
How many number of valid complete plans are evaluated ( One or Two)?
Only One valid complete plan is evaluated
d. Update statistics on the missing statistics columns by turning off the noexec command and then using the update statistics command.

set noexec off

update statistics titles_id (title_id)
update statistics salesdetail_idnum (discount)
update statistics salesdetail_idnum (title_id)

e. Execute the same query (from step 1c) and observe how update statistics makes a difference in Join method and cost of a plan. 

set noexec on
go

select t.title, sd.discount
from titles_id t, salesdetail_idnum sd
where t.title_id = sd.title_id 
and sd.discount = 10


OptCriteria:
append_union_all
alternative_greedy_search
distinct_hashing
distinct_sorted
distinct_sorting
group_hashing
group_sorted
hash_union_distinct
index_union
merge_join
merge_union_all
merge_union_distinct
nary_nl_join
nl_join
order_sorting
parallel_query
replicated_partition
streaming_sort
store_index

Optimization Goal: allrows_mix 
Optimization Learning mode disabled.

Optimization Timeout limit: 10% (Default)
Server Level Optimization Timeout has been set.
Optimization query tuning time limit enabled.
The compiler will use the current best plan when 10%(Optimization Timeout limit) of average execution time is exceeded.

Optimization query tuning mem limit enabled.
The compiler will use the current best plan when 10%(Max Resource Granularity) of procedure cache is exceeded.


***************************************************************
          BEGIN: Search Space Traversal for OptBlock0 
***************************************************************

Scan plans selected for this optblock:


OptBlock0 Eqc{0} -> Pops added: 

	( PopIndScan titidind titles_id t ) cost: 86.39999 T(L3,P3,C54) O(L3,P3,C54) order: {1} 
	
	
OptBlock0 Eqc{1} -> Pops added: 

	( PopTabScan salesdetail_idnum sd ) cost: 119.8 T(L4,P4,C118) O(L4,P4,C118) order: none 
	
	( PopSort ( PopTabScan salesdetail_idnum sd ) ) cost: 131.9 T(L10,P4,C119) O(L6,P0,C1) order: {1} 
	
	

Permutation Order: Gt0( titles_id t ) |X| Gt1( salesdetail_idnum sd )


Join plans selected for this permutation:

OptBlock0 Eqc{0,1} -> Pops added for the join Eqc{0} - Eqc{1}:
	
	( PopMergeJoin ( PopIndScan titidind titles_id t ) ( PopSort ( PopTabScan salesdetail_idnum sd ) ) ) cost: 220.1 T(L13,P6.999999,C191) O(L0,P0,C18) order: none 
	
	

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    DONE: Complete join order evaluation (perm #1)    
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Permutation Order: Gt1( salesdetail_idnum sd ) |X| Gt0( titles_id t )


Join plans selected for this permutation:

OptBlock0 Eqc{0,1} -> Pops added for the join Eqc{1} - Eqc{0}:
	
	( PopNlJoin ( PopTabScan salesdetail_idnum sd ) ( PopIndScan titidind titles_id t ) ) cost: 174.1 T(L6,P5.999999,C121) order: none 
	
	

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    DONE: Complete join order evaluation (perm #2)    
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

===============================================================
       DONE: Left deep tree evaluation (tree #1)
===============================================================

------------------------------------------
Search Engine Statistics (Summary)
------------------------------------------

Total number of tree shapes considered:1
Number of major tree shapes generated:1
Number of tree shapes generated by flipping major tree shapes:0

Number of valid complete plans evaluated:2
Total number of complete plans evaluated:2

------------------------------------------

The best plan found in OptBlock0 : 

( PopNlJoin cost: 174.1 props: [{}] ( PopTabScan cost: 119.8 T(L4,P4,C118) O(L4,P4,C118) props: [{}] Gtt1( salesdetail_idnum sd ) ) cost: 119.8 T(L4,P4,C118) O(L4,P4,C118) order: none 
( PopIndScan cost: 54.3 T(L2,P2,C3) O(L2,P2,C3) props: [{1}] Gti0( titidind ) Gtt0( titles_id t ) ) cost: 54.3 T(L2,P2,C3) O(L2,P2,C3) order: {1} 
) cost: 174.1 order: none 

***************************************************************
          DONE: Search Space Traversal for OptBlock0 
***************************************************************

Which Join method ( Nested Loop Join, Merge Join , Hash Join or N-ary NLJ) is used and what is the cost and is this better than the one without statistics on the columns?
A Nested Loop Join is used and the cost is 174.1 - Yes the cost is lower than the previous method.
How many number of valid complete plans are evaluated ( One or Two)?
Two valid complete plans are evaluated

2. Disable the noexec command and optimizer tracing.

set noexec off
go

dbcc traceoff(3604)
set option show_missing_stats off
set option show_search_engine off

DBCC execution completed. If DBCC printed error messages, contact a user with System Administrator (SA) role.

3. Perform the lab cleanup.
a. In Window A, exit the Adpative Server client session.

exit
b. Change the directory to $HOME/ptquery15.

cd $HOME/ptquery15
c. Execute the UNIX shell script named joins_cleanup.sh:

joins_cleanup.sh

########################################
Cleaned up objects created for Joins ...
########################################



















	



